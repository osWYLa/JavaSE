HashMap
    1)Map接口常用实现类：HashMap、HashTable和Properties;
    2)HashMap是Map接口最常用的实现类；
    3）HashMap以key-value对方式存储数据；
    4）key不能重复，但是值可以重复，允许使用null键和null值；
    5）如果添加相同的key，则会覆盖原来的key处的value值；
    6）与HashSet一样，不保证映射的顺序，因为底层使用hash表的方式存储；
    7）HashMap没有实现同步，因此线程是不安全的

HashMap底层机制：
    (k,v)是一个Mode实现了Map Entry<k,v>
    HashMap底层在不同阶段呈现出不同的特点：
        JDK 7 的hashmap底层实现【数组+链表】
        JDK 8 的hashmap底层实现【数组+链表（前期）/红黑树】

    扩容机制：
    1）HashMap底层维护了Node类型的数组table，默认为null;
    2)创建对象时，将加载因子（loadfactor）初始化为0.75;
    3)添加元素时（调用putVal方法），需要通过该元素的哈希值获取在table中的索引。然后通过判断该索引处是否有元素，
      如果没有元素则直接添加；如果已经存在元素，需要继续判断是否相等，如果相等则直接覆盖此处的value值；如果不相等，
      需要判断是树结构还是链表结构，做出相应处理。如果添加时达到扩容条件，则进行扩容。
    4）第一次添加时，扩容table值为16，临界值（threshold）为16*0.75=12；
    5)后续添加，若需要扩容，扩容table容量为原来的2倍，临界值为原来的两倍；

    HashMap树化过程；
    在极限情况下，HashMap放多少数组会变成红黑树？
    结论：当放入第十个元素时，此时的HashMap还是没有转为红黑二叉树，当放入第十一个元素时，此时的Node转换为TreeNode

        1)开始默认是长度为16的数组；（存放Node）
        2）当某个节点存入的元素超过到8时，有限选择将数组长度扩容为开始的两倍（即扩容为长度为32的数组）；
            （首先认为是由于数组长度不够才导致某个索引中的元素过多）
        3）继续在该节点添加元素，当数组扩容到32时，某个索引中的元素还是超过9时，还是会优先选择将数组长度再次扩容到现在的两倍（扩为64）；
        4）在长度为64的数组中，发现某个索引中的元素还是超过10时，就会将该索引所在的链表转化为红黑树。
        故，在第十一个元素时，就会对该索引所在的链表转化为红黑二叉树；

